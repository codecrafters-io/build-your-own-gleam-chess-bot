slug: "gleam-chess-bot"
name: "Build your own Gleam Chess Bot"
short_name: "Chess Bot"
release_status: "beta"

description_md: |-
  Gleam is a functional programming language that compiles to Erlang. In this challenge
  you'll build your own Gleam Chess Bot.

  Along the way, you'll learn about functional programming, Gleam, and more.

short_description_md: |-
  Learn about functional programming, Gleam, and more

completion_percentage: 30

languages:
  - slug: "gleam"
    release_status: "alpha"
    alpha_tester_usernames: ["isaacharrisholt"]

marketing:
  difficulty: medium
  sample_extension_idea_title: "Persistence"
  sample_extension_idea_description: "A Redis server that can read and write .rdb files"
  testimonials:
    - author_name: "Charles Guo"
      author_description: "Software Engineer, Stripe"
      author_avatar: "https://codecrafters.io/images/external/testimonials/charles-guo.png"
      link: "https://github.com/shaldengeki"
      text: |-
        The Redis challenge was extremely fun. I ended up having to read the
        Redis Protocol specification doc pretty carefully in its entirety! The result
        felt like lightly-guided independent study, if that makes sense. (Which, again, was lots of fun)
    - author_name: "Patrick Burris"
      author_description: "Senior Software Developer, CenturyLink"
      author_avatar: "https://codecrafters.io/images/external/testimonials/patrick-burris.jpeg"
      link: "https://github.com/Jumballaya"
      text: |-
        I think the instant feedback right there in the git push is really cool.
        Didn't even know that was possible!

stages:
  - slug: "jm1"
    concept_slugs:
      [
        "network-protocols",
        "tcp-overview",
        "go-tcp-server",
        "rust-tcp-server",
        "python-tcp-server",
      ]
    name: "Bind to a port"
    description_md: |-
      In this stage, you'll implement a TCP server that listens on port 6379.

      [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) is the underlying protocol used by protocols like HTTP, SSH and others
      you're probably familiar with. Redis clients & servers use TCP to communicate with each other.

      Don't worry if you're unfamiliar with the TCP protocol, or what Redis clients & servers are. You'll learn more about this in the
      next stages.

      ### Tests

      The tester will execute your program like this:

      ```bash
      $ ./your_program.sh
      ```

      It'll then try to connect to your TCP server on port 6379. If the connection succeeds, you'll pass this stage.

      ### Notes

      - 6379 is the default port that Redis uses.
      - If you already have a Redis server running on your machine and listening on port 6379, you'll see a "port already in use" error when running your code. Try stopping the existing Redis server and running your code again.

      {{#reader_is_bot}}
      - In this stage, you can assume that you only need to handle a single client. We'll get to handling multiple clients & multiple requests per client in later stages.
      {{/reader_is_bot}}
    difficulty: very_easy
    marketing_md: |-
      In this stage, you'll start a TCP server on port 6379, which is the
      default port that Redis uses.
    tester_source_code_url: "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_bind.go#L11"
